\chapter{Research Protocol} \label{ch:research-protocol}

\section{Samples / Image Domain}\label{sec:NCS-data-set}

We ultimately perform a multiscale Frangi prefilter on a subset of 201 color images of placental samples from a private database provided by the National Children's Study, which had been prepared for a different study. A detailed description of the data set is given in \cite{chang2017}. A description of the cleaning and fixing procedure of the samples prior to their being photographed is given in \cite{almoussa-ucla-reu}. The samples are provided as XCF files (the native project file for GIMP) and contain four major layers.
\subsection{A representative sample}
The layers together give a hand tracing of the vascular network and perimeter. A sample of overlaid layers in a representative sample (with ID number ``BN0164923'') is given in \cref{fig:NCSlayers}.

\begin{figure}[p] \centering
    \subfloat[Fixed Placental Sample]{        \label{fig:NCSlayers-raw}\includegraphics[width=80mm]{{{T-BN0164923.raw}}}
        }
    \subfloat[Perimeter tracing and Umbilical cord insertion point (UCIP]{
        \label{fig:NCSlayers-P}\includegraphics[width=80mm]{{{T-BN0164923_perimeter_overlay}}}
    }\
    \subfloat[Arterial tracing]{
        \label{fig:NCSlayers-A}\includegraphics[width=80mm]{{{T-BN0164923_arteries_overlay}}}
        }
    \subfloat[Venous tracing]{
        \label{fig:NCSlayers-V}\includegraphics[width=80mm]{{{T-BN0164923_veins_overlay}}}
        }\
    \subfloat[Total Vascular Network]{
        \label{fig:NCSlayers-T}\includegraphics[width=80mm]{{{T-BN0164923_all_layers_overlay}}}
        }
    % should i use the real sample names? or obfuscate?
\caption{A representative placental sample and tracing}
\label{fig:NCSlayers}
\end{figure}

Each layer is roughly 1954x1200 pixels (with some occasional variation).
In \cref{fig:NCSlayers}, we see these four layers of a characteristic sample. \cref{fig:NCSlayers-raw} is the base image. A cleaned, formalin-fixed placenta is placed on a table with a camera a fixed distance away, and a ruler and penny (presumably for redundancy) are placed nearby to aid registration and calibration of the resolution. The resolution of each sample is roughly 46 pixels per centimeter.
\cref{fig:NCSlayers-P} is a tracing (in green) of the perimeter of the placenta. The umbilical cord insertion point (UCIP) is notated in yellow. Two cyan marks are placed on consecutive centimeter markings on the ruler (the dots are enlarged and shown as a darker blue here for clarity).
\cref{fig:NCSlayers-A} and \cref{fig:NCSlayers-V} are each hand traces of the PCSVN, with a layer for each the arteries and veins. These layers are simultaneously overlain on the base image in \cref{fig:NCSlayers-T}. The coloration is meant to indicate the diameter of each vessel. The diameters are binned into 9 discrete widths, odd integers from 3 to 19 pixels. Vessels of smaller diameter are either binned to three or (quite frequently) left untraced. The correspondence between pencil color and (binned) vessel width used in the tracing protocol is given in \cref{tab:widthcolors}.

\begin{table}
    \centering
\begin{tabular}{ccc}
    \hline
    \rule[-1ex]{0pt}{2.5ex}
    vessel width & color (hex value) & color name \\
    \hline 
    \rule[-1ex]{0pt}{2.5ex}
    3 pixels &  \texttt{\#ff006f} &   magenta \\                                      
    \rule[-1ex]{0pt}{2.5ex}
    5 pixels & \texttt{\#a80000}  & dark red \\                                      
    \rule[-1ex]{0pt}{2.5ex}
    7 pixels &  \texttt{\#a800ff} & purple \\                                          
    \rule[-1ex]{0pt}{2.5ex}
    9 pixel s&  \texttt{\#ff00ff}  & light pink \\
    \rule[-1ex]{0pt}{2.5ex}
    11 pixels &  \texttt{\#008aff} & blue \\                                          
    \rule[-1ex]{0pt}{2.5ex}
    13 pixels &  \texttt{\#8aff00} &   green \\                                        
    \rule[-1ex]{0pt}{2.5ex}
    15 pixels &  \texttt{\#ffc800} &  gold \\                                    
    \rule[-1ex]{0pt}{2.5ex}
    17 pixels & \texttt{\#ff8a00}  &  orange \\                                         
    \rule[-1ex]{0pt}{2.5ex}
    19 pixels & \texttt{\#ff0015}   &  bright red  \\
    \hline
\end{tabular}
\caption{Vessel width color code for manual tracing protocol}
\label{tab:widthcolors}
\end{table}


As stated in the introduction, the task of creating these samples, in particular the tracing and estimation involved in creating \cref{fig:NCSlayers-A} and \cref{fig:NCSlayers-V} is very labor intensive--requiring between 4 and 8 hours to trace a single sample.
A closer look at many of the samples often reveals that a great deal of subjectivity in providing this ``ground truth,'' as it is not often clear what the underlying truth really is. Often it's hard to see where the vein is, vascular networks are obscured by the umbilical stem, the blood in the vessels dries unevenly or ruptures, and the vessel seems to disappear momentarily. These situations and more will be showcased in \cref{fig:annotated-montage}, where we will demonstrate how the Frangi filter reacts to these problem areas. Our efforts at the eventual task of network completion must deal with these shortcomings and, in some circumstances, make subjective decisions like the manual tracer did.


\subsection{Knowns and Unknowns}
Since our final goal is a fully automated procedure, we wish to simply operate on the placental sample itself, without any understanding of its provided tracing (except for judging the strength of our algorithm);
our goal is to develop an algorithm that can produce a ``ground truth'' tracing similar to \cref{fig:NCSlayers-T} or \cref{fig:NCSoutput-trace} without any user intervention.

For our purposes however, we will concede and provide a limited amount of information from the tracings, namely the provided placental perimeter (shown in green in \cref{fig:NCSlayers}). In developing a fully automated algorithm, it would be relatively straightforward to obtain this boundary ourselves using various techniques, such as an Active Contour Model \cite{activecontours} or, even a simple edge finding algorithm followed by watershedding and largest object selection. In fact, we have implemented this later algorithm, but unfortunately we achieve a subpar result on several images, and therefore we currently use it to improve upon the perimeter by removing ``cuts'', which were previously reported as being inside the plate and sometimes led to large false positives. %We do use the traced placental perimeter at our own peril, however, since often there are tears in the side of the plate or large amounts of non-vascular content with large changes in height that are not adequately accounted for in the perimeter tracing.

Finally, we will consider the location of the umbilical insertion point as a ``known'', as the vessels around it are frequently impossible to see and we wish to exclude them from consideration. It is not unreasonable, however, to consider this to be a known--in future preparations of samples, we could simply require that this point be centered in image in a predictable location. Furthermore, we use its location as a convenience in data analysis--knowledge of this point does not inform our algorithm at the present time.


\section{Data Cleaning and Preprocessing}

Building a sample suitable for use in our algorithm from \cref{fig:NCSlayers} is relatively simple. We  zero  outside the boundary of the plate (so as to not waste computational time calculating the differential geometry of a ruler, say), and also generate a binary mask to identify the plate. Finally, our vessel layers are combined and given as a binary trace, which we will use later for scoring. An example of the preprocessed samples used by the algorithm are given in \cref{fig:exampleNCSoutput}.

These procedures are performed automatically on the 201 images in our data set using a custom GIMP plug-in, which performs various ``bucket fill'' operations, layer mergings, and thresholdings. For completeness sake, this plug-in (and an associated Scheme script which turns it into a batch operation) can be found in the Appendix.

\begin{figure}\label{fig:exampleNCSoutput}     \centering
    \subfloat[Background mask (in white)]{
        \label{fig:NCSoutput-mask}\includegraphics[width=80mm]{{{T-BN0164923.mask}}}
    }
    \subfloat[Sample with background removed]{
        \label{fig:NCSoutput-base}\includegraphics[width=80mm]{{{T-BN0164923}}}
    } \\
    \subfloat[Grayscale]{
        \label{fig:NCSoutput-gray}\includegraphics[width=80mm]{{{T-BN0164923.L}}}
    }
    \subfloat[Trace / ``Ground Truth'']{
        \label{fig:NCSoutput-trace}\includegraphics[width=80mm]{{{T-BN0164923.trace}}}
    }
    \caption{Preprocessed files from an NCS sample}
\end{figure}

    As a point of technicality, the grayscale image in \cref{fig:NCSoutput-gray} is not actually produced directly by the extractor plug-in, but created when the 3 channel RGB image \cref{fig:NCSoutput-base} is imported at the start of the algorithm. This grayscale conversion is simply done for ease of analysis on the sample: although the Frangi filter is designed for arbitrary $N$-dimensional input \cite{frangi-paper}, an image with three color channels does not have 3 spatial dimensions. We therefore simply combine the information in three channels using the well-known and oft-implemented ITU-R 601-2 luma \cite{scipy}, or ``luminance'' transform:
    
    \begin{equation} \label{eq:luma_transform}
    L =  \frac{299}{1000}\ R + \frac{587}{1000}\ G + \frac{114}{1000}\ B
    \end{equation}
    It should be noted that this choice is not a given--several other attempts have used the green channel unmodified, as in \cite{almoussa-ucla-reu} and \cite{huynh2013filter}. Preliminary and periodical rechecking has not indicated that such a conversion has any benefit over the luminance transformation for our image domain, although other placental samples with a different preparation method might benefit from it.

    \subsection{Boundary Dilation} \label{sec:boundary-dilation}
    
    All images are grayscale, $M,N$ pixels as a masked array (of type
    \texttt{numpy.ma.MaskedArray}), where pixels outside of the placental region are masked so they will not be considered by the algorithm. However, some standard
    implementations of algorithms, namely \texttt{numpy.gradient and scipy.signal.convolve2d} are not designed to handle masked regions. Although it would be potentially useful to adapt such methods in a way to, say, calculate a gradient or perform a convolution by a ``reflection'' across an arbitrary closed boundary (as opposed to the edge of the image matrix), we opted instead to ``zero out'' unwanted background pixels and simply exclude affected areas from consideration. This exclusion could be achieved by
    simply dilating the mask, but we opt to achieve it in a much more resource efficient manner: we iterate through an array of indices for the image where the boundary occurs and simply extend the mask $R$ pixels in each direction (like a giant plus sign). Since the boundary of the placental plate forms a closed loop, the effect is very similar to convolving with a disk of radius $R$, but is much faster.
    
    \begin{figure} 
        \includegraphics[width=\textwidth]{boundary_dilation_demo}
        \caption{Effect of boundary dilation on Frangi responses}
        \label{fig:boundary-demo}
    \end{figure}
    
    \cref{fig:boundary-demo} shows the effect of this so-called ``boundary dilation.'' 
    We show the output of the Frangi filter with $\sigma=3$. A border radius of $25$ is chosen to exaggerate the effect.
    The first row shows the unaltered boundary of the sample (left) and
        the sample after boundary dilation (with radius dilation of 25 pixels).
    The second row shows the Frangi vesselness measure at single scale ($\sigma=3$) where \texttt{DARK\_BG=False} to target dark curvilinear structures performed on the altered sample (left) and the boundary dilated sample (right). Removing an unnecessary part of
    the placental plate prevents a small response to a non-vascular yet mildly curvilinear
    background feature from appearing.
    The third row of \cref{fig:boundary-demo} shows the Frangi vesselness measure at the same scale ($\sigma=3$) when we are probing for bright curvilinear structures (i.e.
    \texttt{DARK\_BG=True}). Here, wherever the very edge of the placental plate is *any* brighter than adjacent interior, a very large Frangi response will occur, as seen on the left. Dilating the boundary completely avoids this issue, as seen by the figure on the right. Thus we prevent a visual artifact that is present in much prior work on this problem (see \cite{huynh2013filter}, \cite{almoussa-ucla-reu}).
    % FIX THIS THIS PROBABLY ISN'T TRUE ANYMORE %RELATIVEMAXBOUNDARYDEMO
    It should be noted that, while the figure on the right shows a much larger interior response, this is simply because the intensity of the output in each of these
    images is being independently scaled between the minimum and maximum intensity in the image. However, we argue that this is an appropriate and desired depiction of the situation, as we will frequently consider only the relative maxima of Frangi response per scale in our analysis.
    
    We end our discussion by noting that we perform this boundary dilation within the
    Frangi algorithm itself when we set the structureness parameter $\gamma$ as half of the maximum Hessian norm found at that scale--this ensures that the maximum occurs sufficiently away from the boundary of the plate, and does not occur from a noise phenomenon.
    
    The code for generating \cref{fig:boundary-demo} is found within the ``\texttt{if \_\_name\_\_ == \_\_main\_\_}'' block of the file \texttt{plate\_morphology.py},
    (so the figure will be generated when running \texttt{plate\_morphology.py} as a top-level script from the command line). See appendix.
    
    
%    Sometimes there are small cuts that appear on the side of the placental plate, which can lead to large filter responses. We would like to filter these out to eliminate false positives in any way we can. These places are identified somewhat reliably by the tracing protocol with a blue dot. We perform a morphological watershedding in this area in an attempt to add this area to the mask.
%    The threshold for the watershed is ultimately based on the background value of the blue dot; if this is incorrectly placed (or anything else weird happens), we can manually opt to simply remove a large area from consideration from the plate, as we do the umbilicial cord insertion point. This is demonstrated in \cref{fig:cutdemo}. From left to right, we have the original masked placental sample, the cut mark notated on the perimeter layer, the improved mask after watershedding, and finally, the ``scorched earth'' approach in case the previous attempt failed. In few additional cases, neither approach is adequate. We again will stress that a fully automated algorithm would have no knowledge of our traced perimeter (as in \cref{fig:NCSlayers-P} or the second from left image in \cref{fig:cutdemo}), so we anticipate a fully automated method of handling that problem should also be able to correct for these ``cuts'' as well.
%    
%    \begin{figure}
%        \centering
%        \includegraphics[width=\linewidth]{T-BN0342010_cutopts}
%        \caption{Removing a ``cut'' from the placental plate.}
%        \label{fig:cutdemo}
%    \end{figure}
    
    \subsection{Finding Placental Border}
		
		We take the gradient of the sample green channel of the raw sample with a very small scale $\sigma=.01$ to identify very small and sharp changes. We then mark the top right pixel, which is certainly outside the placental plate, with a background marker, and we label any points where the gradient is above its mean value as foreground. We then perform a watershed of the gradient given these markers and then perform a binary erosion of the result with radius 15 to regularize the result. From this, we grab the largest foreground object, which will inevitably be the placental
		plate. Unfortunately, there are 7 of the 201 samples for which this procedure fails. In the case of these samples, we revert to simply using the traced outline of the placenta as given by the tracing protocol.
		
		    \subsection{Deglaring}
    
    Despite best efforts when harvesting samples, a select number of the placental samples exhibit substantial glare, which leads to inaccuracies in identifying curvilinear content. Our protocol for deglaring is analogous to that performed in \cite{almoussa-ucla-reu} and \cite{huynh2013filter}. Unfortunately, the method relied upon by those previous papers (\texttt{MATLAB}'s \texttt{imfill}, which relies on inpainting by solving the Dirichlet problem for masked regions) was not immediately available in a Python environment. Instead, we used an already implemented inpainting algorithm, \texttt{scikit-image}'s \texttt{inpaint\_biharmonic()}, which should be expected to achieve similar results, albeit at the expense of processing time.
    
    The function \texttt{inpaint\_biharmonic} is based on \cite{damelin2018surface}, and relies on solving the biharmonic equation i.e. $\nabla \nabla f = 0$
    for the surface $f$ subject to boundary conditions (as
    compared to \texttt{imfill}'s solving the Laplace equation $\nabla f = 0$ in regions marked as glare.
    
    The method for deciding what is considered glare is similar to $\cite{almoussa-ucla-reu}$, in which we
    consider any intensities close the maximum intensity in the image (Almoussa et al. used $80\%$ of max intensity, and we use $175/255 \approx 68\%$). This threshold is unfortunately dependent on the image domain.
    
        \begin{figure} 
        \includegraphics[width=\textwidth]{preprocessing_comparison_cropped_fig}
        \caption{Deglaring a sample using a hybrid inpainting method}
        \label{fig:glare-example-crop}
        \end{figure}

        \begin{figure}[t] \centering
        \includegraphics[width=0.8\textwidth]{preprocessing_comparison_zoomed_fig}
        \caption{Comparison of glare inpainting methods (detail)}
        \label{fig:glare-example-zoom}
        \end{figure}
    
    Inpainting in the above way is rather resource intensive, so we implemented two faster and less precise methods of inpainting that work well enough for removing small regions of glare.
    These methods can be found in \texttt{preprocessing.py}. The first, called 
    \texttt{inpaint\_glare()}, replaces any masked pixel with the average of all non-masked values within a certain distance (default 15 pixels). The second, called \texttt{inpaint\_with\_boundary\_median} calculates the median value of the  (non-masked) boundary and fills any masked region with that value. We argue that these less-exact methods are adequate for smaller regions, while larger regions of glare deserve a more thoughtful application of inpainting. Our final method of inpainting, \texttt{inpaint\_hybrid} implements this idea--smaller glare regions are inpainted with a boundary median, while larger areas are inpainted with the more expensive but more accurate biharmonic inpainting.
    
    A comparison of these methods is shown in \cref{fig:glare-example-crop},
    and a zoomed in portion is shown in \cref{fig:glare-example-zoom}.
    In the top left of each, the glary image is shown.  In the top middle,
    regions above the threshold intensity are masked (shown in dark red, along with the background). In the top right, the strategy is ``mean window'' with a window size of 15 pixels. The bottom left uses ``boundary median'' strategy. The middle is the more expensive ``biharmonic inpainting'' strategy, and the bottom right uses a ``hybrid'' strategy.
    
    The following timing demonstrates that the ``hybrid'' strategy is over 3 times faster than biharmonic inpainting, and that biharmonic painting takes 22 seconds, even when only 1\% of the placental plate is to be inpainted.
    
    Inpainting with boundary median only four seconds, inpainting all sections with the biharmonic method took 22 seconds, and a hybrid method took 6.5 seconds. Roughly 1 percent of nonmasked pixels in the image were inpainted.

%    \begin{lstlisting}
%    In [1]: %timeit inpaint_with_boundary_median(img)
%    1 loop, best of 3: 3.99 s per loop
%    
%    In [2]: %timeit inpaint_with_biharmonic(img)
%    1 loop, best of 3: 22.3 s per loop
%    
%    In [3]: %timeit inpaint_hybrid(img)
%    1 loop, best of 3: 6.49 s per loop
%    
%    In [4]: px_inpainted = np.sum(np.logical_and(masked.mask, np.invert(img.mask)))
%    In [5]: px_plate = np.sum(np.invert(img.mask))
%    In [6]: px_inpainted / px_plate  # ratio of inpainted pixels to total plate 
%    Out[6]: 0.011444460505513942
%    \end{lstlisting}

    
    We stress again that only a small subset our image domain exhibits disruptive amounts of glare for anything except small scales. Future improvements in this direction should probably seek to implement more robust method such as \cite{lange2005glare} that are not dependent on an arbitrary global
    threshold for deciding what regions exhibit glare.
    
    
\section{Multiscale Setup}

    Our multiscale Frangi filter requires a list of scales at which to probe. Each scale is chosen to accentuate features (i.e. vessel diameter) of a particular size.
    This set of scales at which to probe will be denoted as $\Sigma := \{ \sigma_1, \sigma_2, \dots, \sigma_N\}$, where each scale in indexed by increasing order.
    
    Although we cannot expect \textit{a priori} that there is an direct proportionality between our scale size $\sigma$ and (even some function of) the width of a particular vessel \cite{frangi-paper}, we generally expect to isolate
    narrower curvilinear structures at smaller scales, and thicker curvilinear structures at larger scales.  The smallest one should be an effective size where details are expected to be isolated, and the largest should be an effective size as well. In fact, following \cite{Koenderink}, it is reasonable and natural to select these logarithmically; that is, for some selected inputs $m < M$ we have
    
    \begin{equation}
    \sigma_1 = 2^{m} \; , \; \cdots \; , \; \sigma_{j} = 2^{\left(m+\frac{M-m}{N-1}j\right)} \; , \; \cdots \; \sigma_N = 2^{M} \end{equation}
    
    That is, the exponents are spaced linearly from $m$ to $M$. This is achieved by the command
    \texttt{np.logspace(m,M,num=N)}. The idea is that the curvilinear content of the image will respond better at some particular scale, but there are diminishing returns as $\sigma$ increases; while the filter's response may vary substantially between, say $\sigma=1$ and $\sigma=2$, we would not expect a substantial difference in response between, say, $\sigma=46$ and $\sigma=47$. Historically, there was another benefit of using a logarithmic scale space: computing the vesselness measure was very expensive, and thus it was simply not feasible to collect so many large scale readings. This is much less of an issue with the present implementation, although we still obviously wish to avoid frivolous, redundant calculations no matter the speed of the implementation.
    
    The optimal choice of scale sizes to probe at is intuitively dependent on the resolution of the image. If there is no particular care taken in selecting a minimum and maximum scale at which to probe, then we must assure that our Frangi filter is ``normalized'' in such a way that there is a decay in response past certain values. That is, probing at a unreasonably large (or small) scale (say $\sigma=1000$ or $\sigma=.0001$ should result in an almost null response throughout the image. We will approach this issue in our discussion of ``variable thresholding.'' 
    
    \section{The Research Protocol}
    Once we have chosen this set of scales $\Sigma$, we simply convolve the image with a discrete Gaussian kernel with that standard deviation, then take gradients enough to get a matrix of partial second derivatives, the Hessian. We calculate the eigenvalues of each (2x2) Hessian matrix and then compute the Frangi filter according to \cref{ch:unifrangi} and \cref{ch:multifrangi}. We use these to provide a couple examples of estimating the PCSVN network. The entire decision tree can be shown in the outline below. We follow the procedure for \cref{ch:segmentation}. For our analysis of the Frangi filter apart from segmentation we shall stop before step (C).
    
    \begin{spacing}{1}
    \begin{small}
    \begin{verbatim} % DECISION TREE
For each sample:

A) Preprocessing
  1) Find placental border
  	a) Gradient of green channel for small sigma=.01
  	b) Watershed outside against above gradient mean
  	c) erode these points, radius=15
  	d) Identify largest object in watershed threshold
  2) RGB to single channel via Luminance Transform
  3) Glare removal
    a) Mask glare (threshold at *175/255*)
    b) Dilate glare mask with radius=2
    c) Inpaint glare
      + Hybrid inpainting, with size threshold *32*
      . Biharmonic inpainting
      . Median value of boundary
  4) Dilate around UCIP, add to mask (radius=50)
B) Multiscale Frangi filter
  1) Set parameters
    a) Scales
      = n_scales (default: *20*)
      = log_range (default *[-1.5, 3.2]*), log base 2
      -> scales
    b) Beta = 0.1, Gamma = 1.0 (or alternate parametrization)
    d) Dilate mask per scale (20 pixels)
  2) For each sigma: compute Uniscale Frangi Filter
    a) gauss blur image with discrete Gaussian kernel FFT
    b) take gradient across each axis of blurred image;
       take gradient across each axis of gradient
       -> (Hxx, Hxy, Hyy)
    c) Find eigenvalues of hessian at each point (using np.eig)
       and sort by absolute magnitude 
    d) Calculate Frangi Vesselness Measure
  3) Split positive and negative strain.
  3) Merge each result, reserve positive and negative stacks
C) Estimate PCSVN
  1) Approximate using strategy
    a) Calculate Vmax above high fixed threshold
    b) Calculate Vmax above lower fixed threshold
    b) Threshold scalewise at 95th nonzero-percentile
    c) Threshold scalewise at 98th nonzero-percentile
    d) Margin adding algorithm with high fixed threshold
  2) Compare to Trace to obtain confusion matrix
  3) Calculate MCC score and precision
\end{verbatim}
    \end{small}
\end{spacing}
